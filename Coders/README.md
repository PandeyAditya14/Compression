# Coders
Coders are used to assign symbols to charecters using the probablity distribution. The most probable character is assigned the smallest code and the character with least probablity are assigned the longest code.<br>
[<strong>Variable Length Code</strong> ](https://en.wikipedia.org/wiki/Variable-length_code#:~:text=In%20coding%20theory%20a%20variable,read%20back%20symbol%20by%20symbol.)is assigned in a way that.
1. The mapping is Injective that is every charechter is assigned a unique code and every code is representing only a single symbol in data. ([Injection Function](https://en.wikipedia.org/wiki/Injective_function))
2. No Code that has been already assigned can not be a prefix for any other symbol code.

Some example of variable length Coding are;
1. Huffman Coding
2. Lempel-Ziv coding
3. Arithmetic Coding
4. Context-Adaptive Coding

## Huffman Encoding
The whole process is divided into 4 broad steps which are:
1. Frequency count and building frequency table:
2. Creating Huffman tree
3. Creating Encoding map
4. Encoding the given file

### Frequency count and building frequency table
```C++
map<int,int> buildFrequencyTable(istream& input)
```
We take the input as a file pointer and and return a map of int size data (in case of text this will be ASCII value of charecters )and their respective frequency count.

<b>Important Point</b>
1. We also take into account the EOF character and keep it's count as 1.
2. An emtpy file will be have a count of 1 for PSUEDO_EOF.
3. Use int for taking input as it will be able to handle not only text but Audio and Video as well.

### Building Huffman Tree.

Now Huffman Tree is a binary tree with a special set of rule where all the leave nodes represent the symbols in the file and they are ordered is such a way that the most probable Symbol to occur (or the most common symbol ) is at the top most layer.

In Huffman tree every left move signifies <b>'0'</b> and every right move signifies <b>'1'</b>.

To build a Huffman tree we require to use a priority queue which will help find the smallest nodes which least probable to occur at every stage of tree building. You can read about the huffman algorithm in more detail [here](http://mathworld.wolfram.com/HuffmanCoding.html).

Now we need to take every entry form the map generated in the last step and create Huffman node and insert into to priority queue where the frequency count is the comparator. The function declaration will along the lines of.
```C++
HuffmanNode* buildEncodingTree(const map<int,int>& freqTable)
```
We will take the Frequency table as input and generate the Huffman Encoded Tree as the output and return the head of the tree.

### Building the Encoding Map
After we have successfuly built the Encoding tree we now have to build a Map of every symbol and the code generated by the tree. To do this we will traverse the whole tree ( Using DFS ) and upon reaching the leaf node store the generated code into the map.
We use every left move as '0' and right move as '1' and prepend the code generated at every move to the code generated at the previous levels and store the same as code for every symbol when we reach to them( leaf Node ).

Our function Declaration will be.
```C++
map<int,string> buildEncodingMap(HuffmanNode* encodingTree)
```
In this function we take the head of the binary tree as input and generate the mapping of the symbol and code generated and output it as a map of int and string. This string might then be converted to binary or int or written to the output file as a single bit.

### Encode File

Here we take the mapping generated at the previous step to encode the Input file int the encoded version.

```C++
void encodeData(istream& input, const Map<int, string>& encodingMap, obitstream& output)
```

### Decoding an Encode file

All the four major steps mentioned above are only concerned to the encoding of the file for decoding we will need to simply read the file bitwise and traverse the Huffman tree and decode with the respect to the symbols generated now. To this we will have to somehow send the tree to the decoder as this may not be possible in everyr case we can send the decoder the information used to build the Huffman tree which is the frequency table. We can append the frequency table to the encoded file and then during the decoding process we can use this information to build the huffman tree and then decode the file appropriately.